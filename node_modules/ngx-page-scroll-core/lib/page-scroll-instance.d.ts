import { EventEmitter } from '@angular/core';
import { PageScrollConfig } from './types/page-scroll.config';
import { PageScrollTarget } from './types/page-scroll-target';
import { PageScrollViews } from './types/page-scroll-view';
import { EasingLogic } from './types/easing-logic';
/**
 * An Interface specifying the possible options to be passed into the newInstance() factory method
 */
export interface PageScrollOptions extends PageScrollConfig {
    /**
     * The document object of the current app
     */
    document: Document;
    /**
     * A specification of the DOM element to scroll to. Either a string referring to an
     * element using a valid css selector (`#target`, `.class`, `div.class`) or a HTMLElement
     * that is attached to the document's DOM tree.
     */
    scrollTarget: PageScrollTarget;
    /**
     * Array of HTMLElements or the body object that should be manipulated while performing
     * the scroll animation.
     */
    scrollViews?: PageScrollViews[];
    /**
     * Maximum speed to be used for the scroll animation. Only taken
     * into account of no duration is provided
     */
    speed?: number;
    /**
     * A listener to be called whenever the scroll animation stops
     */
    scrollFinishListener?: EventEmitter<boolean>;
    namespace?: string;
    verticalScrolling?: boolean;
    duration?: number;
    scrollOffset?: number;
    advancedInlineOffsetCalculation?: boolean;
    interruptEvents?: string[];
    interruptKeys?: string[];
    interruptible?: boolean;
    scrollInView?: boolean;
    easingLogic?: EasingLogic;
}
/**
 * Represents a scrolling action
 */
export declare class PageScrollInstance {
    pageScrollOptions: PageScrollOptions;
    private isInlineScrolling;
    private interruptListener;
    /**
     * These properties will be set/manipulated if the scroll animation starts
     */
    startScrollPosition: number;
    targetScrollPosition: number;
    distanceToScroll: number;
    startTime: number;
    endTime: number;
    executionDuration: number;
    interruptListenersAttached: boolean;
    timer: any;
    /**
     * Private constructor, requires the properties assumed to be the bare minimum.
     * Use the factory methods to create instances:
     *      {@link PageScrollService#create}
     */
    constructor(pageScrollOptions: PageScrollOptions);
    private static getScrollingTargetPosition;
    private static getInlineScrollingTargetPosition;
    getScrollPropertyValue(scrollingView: any): number;
    getScrollClientPropertyValue(scrollingView: any): number;
    /**
     * Extract the exact location of the scrollTarget element.
     *
     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be
     * a string like "#heading2", then this method returns the corresponding DOM element for that id.
     *
     */
    extractScrollTargetPosition(): {
        top: number;
        left: number;
    };
    /**
     * Get the top offset of the scroll animation.
     * This automatically takes the offset location of the scrolling container/scrolling view
     * into account (for nested/inline scrolling).
     */
    getCurrentOffset(): number;
    /**
     * Sets the "scrollTop" or "scrollLeft" property for all scrollViews to the provided value
     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.
     *          false if it failed for all ScrollViews, meaning that we should stop the animation
     *          (probably because we're at the end of the scrolling region)
     */
    setScrollPosition(position: number): boolean;
    /**
     * Trigger firing a animation finish event
     * @param value Whether the animation finished at the target (true) or got interrupted (false)
     */
    fireEvent(value: boolean): void;
    /**
     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter
     * will be called if any of the attached events is fired.
     *
     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.
     */
    attachInterruptListeners(interruptReporter: InterruptReporter): void;
    /**
     * Remove event listeners from the body and stop listening for events that might be treated as "animation
     * interrupt" events.
     */
    detachInterruptListeners(): void;
    private getScrollTargetElement;
}
/**
 * An Interface a listener should implement to be notified about possible interrupt events
 * that happened due to user interaction while a scroll animation takes place.
 *
 * The PageScrollService provides an implementation to a PageScrollInstance to be notified
 * about scroll animation interrupts and stop related animations.
 */
export interface InterruptReporter {
    report(event: Event, pageScrollInstance: PageScrollInstance): void;
}
