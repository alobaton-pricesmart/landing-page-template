{"version":3,"file":"infinite-list.directive.js","sourceRoot":"","sources":["../../../../../../.ng_build/theme/components/list/infinite-list.directive.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Directive,\n  Input,\n  HostListener,\n  ElementRef,\n  EventEmitter,\n  Output,\n  OnDestroy,\n  AfterViewInit,\n  ContentChildren,\n  QueryList,\n} from '@angular/core';\nimport { Observable, forkJoin, of as observableOf, interval, timer } from 'rxjs';\nimport { takeWhile, filter, switchMap, map, takeUntil, take } from 'rxjs/operators';\nimport { convertToBoolProperty } from '../helpers';\nimport { NbLayoutScrollService } from '../../services/scroll.service';\nimport { NbLayoutRulerService } from '../../services/ruler.service';\nimport { NbListItemComponent } from './list.component';\n\nexport class NbScrollableContainerDimentions {\n  scrollTop: number;\n  scrollHeight: number;\n  clientHeight: number;\n}\n\n/**\n * Infinite List Directive\n *\n * ```html\n *  <nb-list nbInfiniteList [threshold]=\"500\" (bottomThreshold)=\"loadNext()\">\n *    <nb-list-item *ngFor=\"let item of items\"></nb-list-item>\n *  </nb-list>\n * ```\n *\n * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)\n *\n * Directive will notify when list scrolled up or down to a given threshold.\n * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.\n *\n * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)\n *\n * To improve UX of infinite lists, it's better to keep current page in url,\n * so user able to return to the last viewed page or to share a link to this page.\n * `nbListPageTracker` directive will help you to know, what page user currently viewing.\n * Just put it on a list, set page size and it will calculate page that currently in viewport.\n * You can [open the example](example/infinite-list/infinite-news-list.component)\n * in a new tab to check out this feature.\n *\n * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)\n *\n * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)\n *\n */\n@Directive({\n  selector: '[nbInfiniteList]',\n})\nexport class NbInfiniteListDirective implements AfterViewInit, OnDestroy {\n\n  private alive = true;\n  private lastScrollPosition;\n  windowScroll = false;\n  private get elementScroll() {\n    return !this.windowScroll;\n  }\n\n  /**\n   * Threshold after which event load more event will be emited.\n   * In pixels.\n   */\n  @Input()\n  threshold: number;\n\n  /**\n   * By default component observes list scroll position.\n   * If set to `true`, component will observe position of page scroll instead.\n   */\n  @Input()\n  set listenWindowScroll(value) {\n    this.windowScroll = convertToBoolProperty(value);\n  }\n\n  /**\n   * Emits when distance between list bottom and current scroll position is less than threshold.\n   */\n  @Output()\n  bottomThreshold = new EventEmitter(true);\n\n  /**\n   * Emits when distance between list top and current scroll position is less than threshold.\n   */\n  @Output()\n  topThreshold = new EventEmitter(true);\n\n  @HostListener('scroll')\n  onElementScroll() {\n    if (this.elementScroll) {\n      this.checkPosition(this.elementRef.nativeElement);\n    }\n  }\n\n  @ContentChildren(NbListItemComponent) listItems: QueryList<NbListItemComponent>;\n\n  constructor(\n    private elementRef: ElementRef,\n    private scrollService: NbLayoutScrollService,\n    private dimensionsService: NbLayoutRulerService,\n  ) {}\n\n  ngAfterViewInit() {\n    this.scrollService.onScroll()\n      .pipe(\n        takeWhile(() => this.alive),\n        filter(() => this.windowScroll),\n        switchMap(() => this.getContainerDimensions()),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n    this.listItems.changes\n      .pipe(\n        takeWhile(() => this.alive),\n        // For some reason, changes are emitted before list item removed from dom,\n        // so dimensions will be incorrect.\n        // Check every 50ms for a second if dom and query are in sync.\n        // Once they synchronized, we can get proper dimensions.\n        switchMap(() => interval(50).pipe(\n          takeUntil(timer(1000)),\n          filter(() => this.inSyncWithDom()),\n          take(1),\n        )),\n        switchMap(() => this.getContainerDimensions()),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n      this.getContainerDimensions().subscribe(dimentions => this.checkPosition(dimentions));\n  }\n\n  ngOnDestroy() {\n    this.alive = false;\n  }\n\n  checkPosition({ scrollHeight, scrollTop, clientHeight }: NbScrollableContainerDimentions) {\n    const initialCheck = this.lastScrollPosition == null;\n    const manualCheck = this.lastScrollPosition === scrollTop;\n    const scrollUp = scrollTop < this.lastScrollPosition;\n    const scrollDown = scrollTop > this.lastScrollPosition;\n    const distanceToBottom = scrollHeight - scrollTop - clientHeight;\n\n    if ((initialCheck ||  manualCheck || scrollDown) && distanceToBottom <= this.threshold) {\n      this.bottomThreshold.emit();\n    }\n    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {\n      this.topThreshold.emit();\n    }\n\n    this.lastScrollPosition = scrollTop;\n  }\n\n  private getContainerDimensions(): Observable<NbScrollableContainerDimentions> {\n    if (this.elementScroll) {\n      const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;\n      return observableOf({ scrollTop, scrollHeight, clientHeight });\n    }\n\n    return forkJoin(this.scrollService.getPosition(), this.dimensionsService.getDimensions())\n      .pipe(\n          map(([scrollPosition, dimensions]) => ({\n            scrollTop: scrollPosition.y,\n            scrollHeight: dimensions.scrollHeight,\n            clientHeight: dimensions.clientHeight,\n          })),\n      );\n  }\n\n  private inSyncWithDom(): boolean {\n    return this.elementRef.nativeElement.children.length === this.listItems.length;\n  }\n}\n"]}